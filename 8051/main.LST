C51 COMPILER V7.08   MAIN                                                                  06/06/2024 18:09:20 PAGE 1   


C51 COMPILER V7.08, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h> //包含標頭檔
   2          #include <stdlib.h>
   3          #include <string.h>
   4          #include "uart.h"
   5          #include "delay.h"
   6          #include "keyscan.h"
   7          typedef unsigned char byte;
   8          typedef unsigned int  word;
   9          
  10          #define DataPort P0 //定義資料埠 
  11          #define KeyPort P1      //定義鍵盤埠
  12          sbit k1 = P3 ^ 0;
  13          sbit k2 = P3 ^ 1;
  14          sbit LATCH1 = P3 ^ 7;   //定義鎖存使能埠 段鎖存
  15          sbit LATCH2 = P3 ^ 6;   //              位鎖存
  16          
  17          unsigned char code dofly_DuanMa[] = { 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,
  18                                                                                    0x77,0x7c,0x39,0x5e,0x79,0x71 };      // 段碼0~F
  19          unsigned char code dofly_WeiMa[] = { 0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f };//位碼
  20          byte TempData[8];
  21          word mynum[5], myLife, oppoLife;
  22          bit catchable = 0;
  23          
  24          // state
  25          #define WAIT 0
  26          #define PREPARE 1
  27          #define GUESS 2
  28          #define END 3
  29          
  30          /*------------------------------------------------
  31                                          計時器初始化副程式
  32          ------------------------------------------------*/
  33          void Init_Timer0(void) {
  34   1              TMOD |= 0x01;//使用模式1，16位元計時器，使用"|"符號可以在使用多個計時器時不受
             -影響
  35   1              EA = 1;      //總中斷打開
  36   1              ET0 = 1;     //計時器中斷打開
  37   1              TR0 = 1;     //計時器開關打開
  38   1      }
  39          /*------------------------------------------------
  40                                  顯示函數，用於動態掃瞄數碼管
  41          ------------------------------------------------*/
  42          void Display(unsigned char FirstBit, unsigned char Num) {
  43   1              static unsigned char i = 0;
  44   1      
  45   1              DataPort = 0;   //清空資料，防止有交替重影
  46   1              LATCH1 = 1;     //段鎖存
  47   1              LATCH1 = 0;
  48   1      
  49   1              DataPort = dofly_WeiMa[i + FirstBit]; //取位碼 
  50   1              LATCH2 = 1;     //位鎖存
  51   1              LATCH2 = 0;
  52   1      
  53   1              DataPort = TempData[i]; //取顯示資料，段碼
  54   1              LATCH1 = 1;     //段鎖存
C51 COMPILER V7.08   MAIN                                                                  06/06/2024 18:09:20 PAGE 2   

  55   1              LATCH1 = 0;
  56   1      
  57   1              i++;
  58   1              if (i == Num)
  59   1                      i = 0;
  60   1      }
  61          /*------------------------------------------------
  62                                           計時器中斷副程式
  63          ------------------------------------------------*/
  64          void Timer0_isr(void) interrupt 1
  65          {
  66   1              TH0 = (65536 - 2000) / 256;               //重新賦值 2ms
  67   1              TL0 = (65536 - 2000) % 256;
  68   1              Display(0, 8);       // 調用數碼管掃瞄
  69   1              TF1 = 0;
  70   1      }
  71          
  72          char itos(word x) {
  73   1              if (x == 10) return 'A';
  74   1              else return x + '0';
  75   1      }
  76          int ctoi(char x) {
  77   1              if (x == 'A') return 10;
  78   1              else return x - '0';
  79   1      }
  80          
  81          byte wait_input(word x) {//等待輸入
  82   1              byte key;
  83   1              key = KeyPro();
  84   1              while (key == 0xff) {
  85   2                      TempData[x] = TempData[x] ^ 0x80;
  86   2                      key = KeyPro();
  87   2                      DelayMs(30);
  88   2              }
  89   1              TempData[x] = TempData[x] & 0x7f;
  90   1              return key;
  91   1      }
  92          void clearData() {//清屏
  93   1              word i;
  94   1              for (i = 0;i < 8;i++) TempData[i] = 0;
  95   1      }
  96          void switch_show() {
  97   1              word i;
  98   1              byte key, temp[8];
  99   1              for (i = 0;i < 8;i++) temp[i] = TempData[i]; //儲存
 100   1              clearData();//清屏
 101   1              TempData[0] = dofly_DuanMa[mynum[0]];
 102   1              TempData[1] = dofly_DuanMa[mynum[1]];
 103   1              TempData[2] = dofly_DuanMa[mynum[2]];
 104   1              TempData[3] = dofly_DuanMa[mynum[3]];
 105   1              TempData[4] = dofly_DuanMa[mynum[4]];
 106   1              TempData[7] = dofly_DuanMa[myLife];
 107   1              key = wait_input(7);
 108   1              while (key != 12) key = wait_input(7);
 109   1              for (i = 0;i < 8;i++) TempData[i] = temp[i]; //還原
 110   1      }
 111          
 112          void main(void) {
 113   1              char guess[5];
 114   1              byte key;
 115   1              word state = PREPARE, guess_cnt = 0, guess_num = 0;
 116   1              word oppo_guess_cnt = 0, oppo_guess_num = 1;
C51 COMPILER V7.08   MAIN                                                                  06/06/2024 18:09:20 PAGE 3   

 117   1              InitUART();
 118   1              Init_Timer0();
 119   1              ES = 1;// 打開串口中斷
 120   1              while (1) {
 121   2                      if (state == WAIT) {// 等待UART輸入
 122   3                              if (TempData[0] != 0x38) {
 123   4                                      clearData();//清屏
 124   4                                      // 顯示LOAd
 125   4                                      TempData[0] = 0x38, TempData[1] = 0x3f;
 126   4                                      TempData[2] = 0x77, TempData[3] = 0x5e;
 127   4                                      TempData[4] = 0x80, TempData[5] = 0x80;
 128   4                                      TempData[6] = 0x80;
 129   4                              }
 130   3                              if (rec_flag == 1) {// UART輸入
 131   4                                      clearData();//清屏
 132   4                                      buf[head] = '\0';
 133   4                                      if (buf[0] == 'W') {// 猜對
 134   5                                              // 顯示TrUE
 135   5                                              TempData[0] = 0x78, TempData[1] = 0x50;
 136   5                                              TempData[2] = 0x3e, TempData[3] = 0x79;
 137   5                                              state = PREPARE;
 138   5                                      }
 139   4                                      else if (buf[0] == 'L') {// 猜錯
 140   5                                              // 顯示FALSE
 141   5                                              TempData[0] = 0x71, TempData[1] = 0x77;
 142   5                                              TempData[2] = 0x38, TempData[3] = 0x6d;
 143   5                                              TempData[4] = 0x79;
 144   5                                              state = PREPARE;
 145   5                                      }
 146   4                                      else if (buf[0] == 'G') {// 每輪結束
 147   5                                              // 顯示End  X-Y
 148   5                                              myLife = ctoi(buf[5]);
 149   5                                              oppoLife = ctoi(buf[6]);
 150   5                                              TempData[0] = 0x79, TempData[1] = 0x54;
 151   5                                              TempData[2] = 0x5e, TempData[5] = dofly_DuanMa[ctoi(buf[5])];
 152   5                                              TempData[6] = 0x40, TempData[7] = dofly_DuanMa[ctoi(buf[6])];
 153   5                                              if (ctoi(buf[5]) <= 0 || ctoi(buf[6]) <= 0)state = END;
 154   5                                              else state = PREPARE;
 155   5                                      }
 156   4                                      else if (buf[0] == 'T') {// 輪到我猜
 157   5                                              oppo_guess_cnt = 0, oppo_guess_num = 1;
 158   5                                              state = GUESS;
 159   5                                      }
 160   4                                      else if (buf[0] == 'O') {// 接收對方猜「X個Y」
 161   5                                              // 顯示OPPO X Y
 162   5                                              TempData[0] = 0x3f, TempData[1] = 0x73;
 163   5                                              TempData[2] = 0x73, TempData[3] = 0x3f;
 164   5                                              oppo_guess_cnt = ctoi(buf[5]), oppo_guess_num = ctoi(buf[6]);
 165   5                                              TempData[5] = dofly_DuanMa[oppo_guess_cnt];
 166   5                                              TempData[7] = dofly_DuanMa[oppo_guess_num];
 167   5                                              key = wait_input(7);
 168   5                                              while (key != 15) key = wait_input(7);
 169   5                                              clearData();//清屏
 170   5                                              catchable = 1;//可以抓
 171   5                                              state = GUESS;
 172   5                                      }
 173   4                                      else {// 得到我的數字
 174   5                                              // 顯示我的數字
 175   5                                              mynum[0] = ctoi(buf[0]);
 176   5                                              mynum[1] = ctoi(buf[1]);
 177   5                                              mynum[2] = ctoi(buf[2]);
 178   5                                              mynum[3] = ctoi(buf[3]);
C51 COMPILER V7.08   MAIN                                                                  06/06/2024 18:09:20 PAGE 4   

 179   5                                              mynum[4] = ctoi(buf[4]);
 180   5                                              TempData[0] = dofly_DuanMa[mynum[0]];
 181   5                                              TempData[1] = dofly_DuanMa[mynum[1]];
 182   5                                              TempData[2] = dofly_DuanMa[mynum[2]];
 183   5                                              TempData[3] = dofly_DuanMa[mynum[3]];
 184   5                                              TempData[4] = dofly_DuanMa[mynum[4]];
 185   5                                              state = PREPARE;
 186   5                                      }
 187   4                                      rec_flag = 0;
 188   4                                      head = 0;
 189   4                              }
 190   3                      }
 191   2                      else if (state == GUESS) {// 猜測階段
 192   3                              while (state == GUESS) {
 193   4                                      if (TempData[0] != 0x6f) {
 194   5                                              clearData();
 195   5                                              // 顯示GUESS 
 196   5                                              TempData[0] = 0x6f, TempData[1] = 0x3e;
 197   5                                              TempData[2] = 0x79, TempData[3] = 0x6d;
 198   5                                              TempData[4] = 0x6d;
 199   5                                      }
 200   4                                      key = KeyPro();
 201   4                                      if (key >= 1 && key <= 10) {
 202   5                                              while (key != 15) {
 203   6                                                      if (key >= 1 && key <= 10) guess_cnt = key;
 204   6                                                      else if (key == 12) switch_show();
 205   6                                                      TempData[5] = dofly_DuanMa[guess_cnt];
 206   6                                                      key = KeyPro();
 207   6                                                      while (key == 0xff) key = wait_input(5);
 208   6                                              }
 209   5                                              TempData[6] = 0x40;
 210   5                                              key = KeyPro();
 211   5                                              while (!(key >= 1 && key <= 6)) {
 212   6                                                      key = KeyPro();
 213   6                                                      if (key == 12) switch_show();
 214   6                                              }
 215   5                                              while (key != 15) {
 216   6                                                      if (key >= 1 && key <= 6) guess_num = key;
 217   6                                                      else if (key == 12) switch_show();
 218   6                                                      TempData[7] = dofly_DuanMa[guess_num];
 219   6                                                      key = wait_input(7);
 220   6                                                      while (key == 0xff) key = wait_input(7);
 221   6                                              }
 222   5                                              guess[0] = itos(guess_cnt);
 223   5                                              guess[1] = itos(guess_num);
 224   5                                              guess[2] = '\0';
 225   5                                              if ((guess_cnt == oppo_guess_cnt && guess_num <= oppo_guess_num) || (guess_cnt < oppo_guess_cnt)) {
 226   6                                                      //顯示Error
 227   6                                                      TempData[0] = 0x79, TempData[1] = 0x50;
 228   6                                                      TempData[2] = 0x50, TempData[3] = 0x5c;
 229   6                                                      TempData[4] = 0x50;
 230   6                                                      key = wait_input(7);
 231   6                                                      while (key != 15) key = wait_input(7);
 232   6                                                      clearData();
 233   6                                                      // 顯示OPPO X Y
 234   6                                                      TempData[0] = 0x3f, TempData[1] = 0x73;
 235   6                                                      TempData[2] = 0x73, TempData[3] = 0x3f;
 236   6                                                      oppo_guess_cnt = ctoi(buf[5]), oppo_guess_num = ctoi(buf[6]);
 237   6                                                      TempData[5] = dofly_DuanMa[oppo_guess_cnt];
 238   6                                                      TempData[7] = dofly_DuanMa[oppo_guess_num];
 239   6                                                      key = wait_input(7);
 240   6                                                      while (key != 15) key = wait_input(7);
C51 COMPILER V7.08   MAIN                                                                  06/06/2024 18:09:20 PAGE 5   

 241   6                                                      continue;
 242   6                                              }
 243   5                                              UART_SendStr(guess);// 傳送猜測
 244   5                                              state = WAIT;
 245   5                                      }
 246   4                                      else if (key == 15 && catchable) {// 抓
 247   5                                              UART_SendStr("STOP");
 248   5                                              catchable = 0;
 249   5                                              state = WAIT;
 250   5                                      }
 251   4                                      else if (key == 12) switch_show();
 252   4                              }
 253   3                      }
 254   2                      else if (state == PREPARE) {
 255   3                              key = wait_input(7);
 256   3                              while (key != 15) key = wait_input(7);
 257   3                              UART_SendStr("READY");// 準備完成
 258   3                              state = WAIT;
 259   3                      }
 260   2                      else if (state == END) {
 261   3                              key = wait_input(7);
 262   3                              while (!(key == 15 || key == 14)) key = wait_input(7);
 263   3                              if (key == 14) break;
 264   3                              else {
 265   4                                      clearData();// 清屏
 266   4                                      state = PREPARE;
 267   4                              }
 268   3                      }
 269   2              }
 270   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1259    ----
   CONSTANT SIZE    =     35    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      29
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
