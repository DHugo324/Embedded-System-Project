C51 COMPILER V7.08   MAIN                                                                  06/05/2024 22:03:36 PAGE 1   


C51 COMPILER V7.08, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h> //包含標頭檔
   2          #include <stdlib.h>
   3          #include <string.h>
   4          #include "uart.h"
   5          #include "delay.h"
   6          #include "keyscan.h"
   7          typedef unsigned char byte;
   8          typedef unsigned int  word;
   9          
  10          #define DataPort P0 //定義資料埠 
  11          #define KeyPort P1      //定義鍵盤埠
  12          sbit k1 = P3 ^ 0;
  13          sbit k2 = P3 ^ 1;
  14          sbit LATCH1 = P3 ^ 7;   //定義鎖存使能埠 段鎖存
  15          sbit LATCH2 = P3 ^ 6;   //              位鎖存
  16          
  17          unsigned char code dofly_DuanMa[] = { 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,
  18                                                                                    0x77,0x7c,0x39,0x5e,0x79,0x71 };      // 段碼0~F
  19          unsigned char code dofly_WeiMa[] = { 0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f };//位碼
  20          byte TempData[8];
  21          word mynum[5];
  22          bit catchable = 0;
  23          
  24          // state
  25          #define WAIT 0
  26          #define PREPARE 1
  27          #define GUESS 2
  28          #define END 3
  29          
  30          /*------------------------------------------------
  31                                          計時器初始化副程式
  32          ------------------------------------------------*/
  33          void Init_Timer0(void) {
  34   1              TMOD |= 0x01;//使用模式1，16位元計時器，使用"|"符號可以在使用多個計時器時不受
             -影響
  35   1              EA = 1;      //總中斷打開
  36   1              ET0 = 1;     //計時器中斷打開
  37   1              TR0 = 1;     //計時器開關打開
  38   1      }
  39          /*------------------------------------------------
  40                                  顯示函數，用於動態掃瞄數碼管
  41          ------------------------------------------------*/
  42          void Display(unsigned char FirstBit, unsigned char Num) {
  43   1              static unsigned char i = 0;
  44   1      
  45   1              DataPort = 0;   //清空資料，防止有交替重影
  46   1              LATCH1 = 1;     //段鎖存
  47   1              LATCH1 = 0;
  48   1      
  49   1              DataPort = dofly_WeiMa[i + FirstBit]; //取位碼 
  50   1              LATCH2 = 1;     //位鎖存
  51   1              LATCH2 = 0;
  52   1      
  53   1              DataPort = TempData[i]; //取顯示資料，段碼
  54   1              LATCH1 = 1;     //段鎖存
C51 COMPILER V7.08   MAIN                                                                  06/05/2024 22:03:36 PAGE 2   

  55   1              LATCH1 = 0;
  56   1      
  57   1              i++;
  58   1              if (i == Num)
  59   1                      i = 0;
  60   1      }
  61          /*------------------------------------------------
  62                                           計時器中斷副程式
  63          ------------------------------------------------*/
  64          void Timer0_isr(void) interrupt 1
  65          {
  66   1              TH0 = (65536 - 2000) / 256;               //重新賦值 2ms
  67   1              TL0 = (65536 - 2000) % 256;
  68   1              Display(0, 8);       // 調用數碼管掃瞄
  69   1              TF1 = 0;
  70   1      }
  71          
  72          char itos(word x) {
  73   1              if (x == 10) return 'A';
  74   1              else return x + '0';
  75   1      }
  76          int ctoi(char x) {
  77   1              if (x == 'A') return 10;
  78   1              else return x - '0';
  79   1      }
  80          
  81          byte wait_input(word x) {//等待輸入
  82   1              byte key;
  83   1              key = KeyPro();
  84   1              while (key == 0xff) {
  85   2                      TempData[x] = TempData[x] ^ 0x80;
  86   2                      key = KeyPro();
  87   2                      DelayMs(30);
  88   2              }
  89   1              TempData[x] = TempData[x] & 0x7f;
  90   1              return key;
  91   1      }
  92          void clearData() {//清屏
  93   1              word i;
  94   1              for (i = 0;i < 8;i++) TempData[i] = 0;
  95   1      }
  96          void switch_show() {
  97   1              word i;
  98   1              byte key, temp[8];
  99   1              for (i = 0;i < 8;i++) temp[i] = TempData[i]; //儲存
 100   1              clearData();//清屏
 101   1              TempData[0] = dofly_DuanMa[mynum[0]];
 102   1              TempData[1] = dofly_DuanMa[mynum[1]];
 103   1              TempData[2] = dofly_DuanMa[mynum[2]];
 104   1              TempData[3] = dofly_DuanMa[mynum[3]];
 105   1              key = wait_input(7);
 106   1              while (key != 12) key = wait_input(7);
 107   1              for (i = 0;i < 8;i++) TempData[i] = temp[i]; //還原
 108   1      }
 109          
 110          void main(void) {
 111   1              char guess[5];
 112   1              byte key;
 113   1              word state = PREPARE, guess_cnt = 0, guess_num = 0;
 114   1              word oppo_guess_cnt = 0, oppo_guess_num = 1;
 115   1              InitUART();
 116   1              Init_Timer0();
C51 COMPILER V7.08   MAIN                                                                  06/05/2024 22:03:36 PAGE 3   

 117   1              ES = 1;// 打開串口中斷
 118   1              while (1) {
 119   2                      if (state == WAIT) {// 等待UART輸入
 120   3                              if (TempData[0] != 0x38) {
 121   4                                      clearData();//清屏
 122   4                                      // 顯示LOAd
 123   4                                      TempData[0] = 0x38, TempData[1] = 0x3f;
 124   4                                      TempData[2] = 0x77, TempData[3] = 0x5e;
 125   4                                      TempData[4] = 0x80, TempData[5] = 0x80;
 126   4                                      TempData[6] = 0x80;
 127   4                              }
 128   3                              if (rec_flag == 1) {// UART輸入
 129   4                                      clearData();//清屏
 130   4                                      buf[head] = '\0';
 131   4                                      if (buf[0] == 'W') {// 猜對
 132   5                                              // 顯示TrUE
 133   5                                              TempData[0] = 0x78, TempData[1] = 0x50;
 134   5                                              TempData[2] = 0x3e, TempData[3] = 0x79;
 135   5                                              state = PREPARE;
 136   5                                      }
 137   4                                      else if (buf[0] == 'L') {// 猜錯
 138   5                                              // 顯示FALSE
 139   5                                              TempData[0] = 0x71, TempData[1] = 0x77;
 140   5                                              TempData[2] = 0x38, TempData[3] = 0x6e;
 141   5                                              TempData[4] = 0x79;
 142   5                                              state = PREPARE;
 143   5                                      }
 144   4                                      else if (buf[0] == 'G') {// 每輪結束
 145   5                                              // 顯示End  X-Y
 146   5                                              // myLife = ctoi(buf[5]);
 147   5                                              // oppoLiife = ctoi(buf[6]);
 148   5                                              TempData[0] = 0x79, TempData[1] = 0x54;
 149   5                                              TempData[2] = 0x5e, TempData[5] = dofly_DuanMa[ctoi(buf[5])];
 150   5                                              TempData[6] = 0x40, TempData[7] = dofly_DuanMa[ctoi(buf[6])];
 151   5                                              if (ctoi(buf[5]) <= 0 || ctoi(buf[6]) <= 0)state = END;
 152   5                                              else state = PREPARE;
 153   5                                      }
 154   4                                      else if (buf[0] == 'T') {// 輪到我猜
 155   5                                              oppo_guess_cnt = 0, oppo_guess_num = 1;
 156   5                                              state = GUESS;
 157   5                                      }
 158   4                                      else if (buf[0] == 'O') {// 接收對方猜「X個Y」
 159   5                                              // 顯示OPPO X Y
 160   5                                              TempData[0] = 0x3f, TempData[1] = 0x73;
 161   5                                              TempData[2] = 0x73, TempData[3] = 0x3f;
 162   5                                              oppo_guess_cnt = ctoi(buf[5]), oppo_guess_num = ctoi(buf[6]);
 163   5                                              TempData[5] = dofly_DuanMa[oppo_guess_cnt];
 164   5                                              TempData[7] = dofly_DuanMa[oppo_guess_num];
 165   5                                              key = wait_input(7);
 166   5                                              while (key != 15) key = wait_input(7);
 167   5                                              clearData();//清屏
 168   5                                              catchable = 1;//可以抓
 169   5                                              state = GUESS;
 170   5                                      }
 171   4                                      else {// 得到我的數字
 172   5                                              // 顯示我的數字
 173   5                                              mynum[0] = ctoi(buf[0]);
 174   5                                              mynum[1] = ctoi(buf[1]);
 175   5                                              mynum[2] = ctoi(buf[2]);
 176   5                                              mynum[3] = ctoi(buf[3]);
 177   5                                              mynum[4] = ctoi(buf[4]);
 178   5                                              TempData[0] = dofly_DuanMa[mynum[0]];
C51 COMPILER V7.08   MAIN                                                                  06/05/2024 22:03:36 PAGE 4   

 179   5                                              TempData[1] = dofly_DuanMa[mynum[1]];
 180   5                                              TempData[2] = dofly_DuanMa[mynum[2]];
 181   5                                              TempData[3] = dofly_DuanMa[mynum[3]];
 182   5                                              TempData[4] = dofly_DuanMa[mynum[4]];
 183   5                                              state = PREPARE;
 184   5                                      }
 185   4                                      rec_flag = 0;
 186   4                                      head = 0;
 187   4                              }
 188   3                      }
 189   2                      else if (state == GUESS) {// 猜測階段
 190   3                              while (state == GUESS) {
 191   4                                      if (TempData[0] != 0x6f) {
 192   5                                              clearData();
 193   5                                              // 顯示GUESS 
 194   5                                              TempData[0] = 0x6f, TempData[1] = 0x3e;
 195   5                                              TempData[2] = 0x79, TempData[3] = 0x6d;
 196   5                                              TempData[4] = 0x6d;
 197   5                                      }
 198   4                                      key = KeyPro();
 199   4                                      if (key >= 1 && key <= 10) {
 200   5                                              while (key != 15) {
 201   6                                                      if (key >= 1 && key <= 10) guess_cnt = key;
 202   6                                                      else if (key == 12) switch_show();
 203   6                                                      TempData[5] = dofly_DuanMa[guess_cnt];
 204   6                                                      key = KeyPro();
 205   6                                                      while (key == 0xff) key = wait_input(5);
 206   6                                              }
 207   5                                              TempData[6] = 0x40;
 208   5                                              key = KeyPro();
 209   5                                              while (!(key >= 1 && key <= 6)) {
 210   6                                                      key = KeyPro();
 211   6                                                      if (key == 12) switch_show();
 212   6                                              }
 213   5                                              while (key != 15) {
 214   6                                                      if (key >= 1 && key <= 6) guess_num = key;
 215   6                                                      else if (key == 12) switch_show();
 216   6                                                      TempData[7] = dofly_DuanMa[guess_num];
 217   6                                                      key = wait_input(7);
 218   6                                                      while (key == 0xff) key = wait_input(7);
 219   6                                              }
 220   5                                              guess[0] = itos(guess_cnt);
 221   5                                              guess[1] = itos(guess_num);
 222   5                                              guess[2] = '\0';
 223   5                                              if ((guess_cnt == oppo_guess_cnt && guess_num < oppo_guess_num)) {
 224   6                                                      //顯示Error
 225   6                                                      TempData[0] = 0x79, TempData[1] = 0x50;
 226   6                                                      TempData[2] = 0x50, TempData[3] = 0x5c;
 227   6                                                      TempData[4] = 0x50;
 228   6                                                      key = wait_input(7);
 229   6                                                      while (key != 15) key = wait_input(7);
 230   6                                                      clearData();
 231   6                                                      // 顯示OPPO X Y
 232   6                                                      TempData[0] = 0x3f, TempData[1] = 0x73;
 233   6                                                      TempData[2] = 0x73, TempData[3] = 0x3f;
 234   6                                                      oppo_guess_cnt = ctoi(buf[5]), oppo_guess_num = ctoi(buf[6]);
 235   6                                                      TempData[5] = dofly_DuanMa[oppo_guess_cnt];
 236   6                                                      TempData[7] = dofly_DuanMa[oppo_guess_num];
 237   6                                                      key = wait_input(7);
 238   6                                                      while (key != 15) key = wait_input(7);
 239   6                                                      continue;
 240   6                                              }
C51 COMPILER V7.08   MAIN                                                                  06/05/2024 22:03:36 PAGE 5   

 241   5                                              UART_SendStr(guess);// 傳送猜測
 242   5                                              state = WAIT;
 243   5                                      }
 244   4                                      else if (key == 15 && catchable) {// 抓
 245   5                                              UART_SendStr("STOP");
 246   5                                              catchable = 0;
 247   5                                              state = WAIT;
 248   5                                      }
 249   4                                      else if (key == 12) switch_show();
 250   4                              }
 251   3                      }
 252   2                      else if (state == PREPARE) {
 253   3                              key = wait_input(7);
 254   3                              while (key != 15) key = wait_input(7);
 255   3                              UART_SendStr("READY");// 準備完成
 256   3                              state = WAIT;
 257   3                      }
 258   2                      else if (state == END) {
 259   3                              key = wait_input(7);
 260   3                              while (!(key == 15 || key == 14)) key = wait_input(7);
 261   3                              if (key == 14) break;
 262   3                              else {
 263   4                                      clearData();// 清屏
 264   4                                      state = PREPARE;
 265   4                              }
 266   3                      }
 267   2              }
 268   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1222    ----
   CONSTANT SIZE    =     35    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19      29
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
