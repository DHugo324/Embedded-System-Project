C51 COMPILER V7.08   MAIN                                                                  06/03/2024 23:12:14 PAGE 1   


C51 COMPILER V7.08, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h> //包含標頭檔
   2          #include <stdlib.h>
   3          #include <string.h>
   4          #include "uart.h"
   5          #include "delay.h"
   6          #include "keyscan.h"
   7          typedef unsigned char byte;
   8          typedef unsigned int  word;
   9          
  10          #define DataPort P0 //定義資料埠 
  11          #define KeyPort P1      //定義鍵盤埠
  12          sbit k1 = P3 ^ 0;
  13          sbit k2 = P3 ^ 1;
  14          sbit LATCH1 = P3 ^ 7;   //定義鎖存使能埠 段鎖存
  15          sbit LATCH2 = P3 ^ 6;   //              位鎖存
  16          
  17          unsigned char code dofly_DuanMa[] = { 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,
  18                                                                                    0x77,0x7c,0x39,0x5e,0x79,0x71 };      // 段碼0~F
  19          unsigned char code dofly_WeiMa[] = { 0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f };//位碼
  20          byte TempData[8];
  21          word mynum[4];
  22          bit catchable = 0;
  23          
  24          // state
  25          #define WAIT 0
  26          #define PREPARE 1
  27          #define GUESS 2
  28          #define END 3
  29          
  30          /*------------------------------------------------
  31                                          計時器初始化副程式
  32          ------------------------------------------------*/
  33          void Init_Timer0(void) {
  34   1              TMOD |= 0x01;//使用模式1，16位元計時器，使用"|"符號可以在使用多個計時器時不受
             -影響
  35   1              EA = 1;      //總中斷打開
  36   1              ET0 = 1;     //計時器中斷打開
  37   1              TR0 = 1;     //計時器開關打開
  38   1      }
  39          /*------------------------------------------------
  40                                  顯示函數，用於動態掃瞄數碼管
  41          ------------------------------------------------*/
  42          void Display(unsigned char FirstBit, unsigned char Num) {
  43   1              static unsigned char i = 0;
  44   1      
  45   1              DataPort = 0;   //清空資料，防止有交替重影
  46   1              LATCH1 = 1;     //段鎖存
  47   1              LATCH1 = 0;
  48   1      
  49   1              DataPort = dofly_WeiMa[i + FirstBit]; //取位碼 
  50   1              LATCH2 = 1;     //位鎖存
  51   1              LATCH2 = 0;
  52   1      
  53   1              DataPort = TempData[i]; //取顯示資料，段碼
  54   1              LATCH1 = 1;     //段鎖存
C51 COMPILER V7.08   MAIN                                                                  06/03/2024 23:12:14 PAGE 2   

  55   1              LATCH1 = 0;
  56   1      
  57   1              i++;
  58   1              if (i == Num)
  59   1                      i = 0;
  60   1      }
  61          /*------------------------------------------------
  62                                           計時器中斷副程式
  63          ------------------------------------------------*/
  64          void Timer0_isr(void) interrupt 1
  65          {
  66   1              TH0 = (65536 - 2000) / 256;               //重新賦值 2ms
  67   1              TL0 = (65536 - 2000) % 256;
  68   1              Display(0, 8);       // 調用數碼管掃瞄
  69   1              TF1 = 0;
  70   1      }
  71          char* itos(word x) {
  72   1              if (x == 10) return 'A';
  73   1              else return x + '0';
  74   1      }
  75          int stoi(char x) {
  76   1              if (x == 'A') return 10;
  77   1              else return x - '0';
  78   1      }
  79          
  80          byte wait_input(word x) {//等待輸入
  81   1              byte key;
  82   1              key = KeyPro();
  83   1              while (key == 0xff) {
  84   2                      TempData[x] = TempData[x] ^ 0x80;
  85   2                      key = KeyPro();
  86   2                      DelayMs(10);
  87   2              }
  88   1              TempData[x] = TempData[x] & 0x7f;
  89   1              return key;
  90   1      }
  91          void clearData() {//清屏
  92   1              word i;
  93   1              for (i = 0;i < 8;i++) TempData[i] = 0;
  94   1      }
  95          void switch_show() {
  96   1              word i;
  97   1              byte key, temp[8];
  98   1              for (i = 0;i < 8;i++) temp[i] = TempData[i]; //儲存
  99   1              clearData();//清屏
 100   1              TempData[0] = dofly_DuanMa[mynum[0]];
 101   1              TempData[1] = dofly_DuanMa[mynum[1]];
 102   1              TempData[2] = dofly_DuanMa[mynum[2]];
 103   1              TempData[3] = dofly_DuanMa[mynum[3]];
 104   1              key = wait_input(7);
 105   1              while (key != 12) key = wait_input(7);
 106   1              for (i = 0;i < 8;i++) TempData[i] = temp[i]; //還原
 107   1      }
 108          
 109          void main(void) {
 110   1              word state;
 111   1              byte key;
 112   1              word guess_cnt = 0, guess_num = 0;
 113   1              InitUART();
 114   1              Init_Timer0();
 115   1              ES = 1;// 打開串口中斷
 116   1              state = PREPARE;
C51 COMPILER V7.08   MAIN                                                                  06/03/2024 23:12:14 PAGE 3   

 117   1              while (1) {
 118   2                      if (state == WAIT) {// 等待UART輸入
 119   3                              clearData();//清屏
 120   3                              // 顯示LOAd
 121   3                              TempData[0] = 0x38;
 122   3                              TempData[1] = 0x3f;
 123   3                              TempData[2] = 0x77;
 124   3                              TempData[3] = 0x5e;
 125   3                              TempData[4] = 0x80;
 126   3                              TempData[5] = 0x80;
 127   3                              TempData[6] = 0x80;
 128   3                              if (rec_flag == 1) {// UART輸入
 129   4                                      clearData();//清屏
 130   4                                      buf[head] = '\0';
 131   4                                      if (buf[0] == 'W') {// 猜對
 132   5                                              // 顯示TrUE
 133   5                                              TempData[0] = 0x78;
 134   5                                              TempData[1] = 0x50;
 135   5                                              TempData[2] = 0x3e;
 136   5                                              TempData[3] = 0x79;
 137   5                                              state = PREPARE;
 138   5                                      }
 139   4                                      else if (buf[0] == 'L') {// 猜錯
 140   5                                              // 顯示FALSE
 141   5                                              TempData[0] = 0x71;
 142   5                                              TempData[1] = 0x77;
 143   5                                              TempData[2] = 0x38;
 144   5                                              TempData[3] = 0x6e;
 145   5                                              TempData[4] = 0x79;
 146   5                                              state = PREPARE;
 147   5                                      }
 148   4                                      else if (buf[0] == 'G') {// 每輪結束
 149   5                                              // 顯示End  X-Y
 150   5                                              // myLife = stoi(buf[5]);
 151   5                                              // oppoLiife = stoi(buf[6]);
 152   5                                              TempData[0] = 0x79;
 153   5                                              TempData[1] = 0x54;
 154   5                                              TempData[2] = 0x5e;
 155   5                                              TempData[5] = dofly_DuanMa[stoi(buf[5])];
 156   5                                              TempData[6] = 0x40;
 157   5                                              TempData[7] = dofly_DuanMa[stoi(buf[6])];
 158   5                                              if (stoi(buf[5]) <= 0 || stoi(buf[6]) <= 0)state = END;
 159   5                                              else state = PREPARE;
 160   5                                      }
 161   4                                      else if (buf[0] >= '0' && buf[0] <= '6') {// 得到我的數字
 162   5                                              // 顯示我的數字
 163   5                                              mynum[0] = stoi(buf[0]);
 164   5                                              mynum[1] = stoi(buf[1]);
 165   5                                              mynum[2] = stoi(buf[2]);
 166   5                                              mynum[3] = stoi(buf[3]);
 167   5                                              TempData[0] = dofly_DuanMa[mynum[0]];
 168   5                                              TempData[1] = dofly_DuanMa[mynum[1]];
 169   5                                              TempData[2] = dofly_DuanMa[mynum[2]];
 170   5                                              TempData[3] = dofly_DuanMa[mynum[3]];
 171   5                                              state = PREPARE;
 172   5                                      }
 173   4                                      else if (buf[0] == 'T') {// 輪到我猜
 174   5                                              // 顯示GUESS 
 175   5                                              TempData[0] = 0x6f;
 176   5                                              TempData[1] = 0x3e;
 177   5                                              TempData[2] = 0x79;
 178   5                                              TempData[3] = 0x6e;
C51 COMPILER V7.08   MAIN                                                                  06/03/2024 23:12:14 PAGE 4   

 179   5                                              TempData[4] = 0x6e;
 180   5                                              state = GUESS;
 181   5                                      }
 182   4                                      else if (buf[0] == 'O') {// 接收對方猜「X個Y」
 183   5                                              // 顯示OPPO X Y
 184   5                                              TempData[0] = 0x3f;
 185   5                                              TempData[1] = 0x73;
 186   5                                              TempData[2] = 0x73;
 187   5                                              TempData[3] = 0x3f;
 188   5                                              TempData[5] = dofly_DuanMa[stoi(buf[5])];
 189   5                                              TempData[7] = dofly_DuanMa[stoi(buf[6])];
 190   5                                              key = wait_input(7);
 191   5                                              while (key != 15) key = wait_input(7);
 192   5                                              clearData();//清屏
 193   5                                              // 顯示GUESS 
 194   5                                              TempData[0] = 0x6f;
 195   5                                              TempData[1] = 0x3e;
 196   5                                              TempData[2] = 0x79;
 197   5                                              TempData[3] = 0x6e;
 198   5                                              TempData[4] = 0x6e;
 199   5                                              catchable = 1;
 200   5                                              state = GUESS;
 201   5                                      }
 202   4                                      rec_flag = 0;
 203   4                                      head = 0;
 204   4                              }
 205   3                      }
 206   2                      else if (state == GUESS) {// 猜測階段
 207   3                              key = KeyPro();
 208   3                              if (key >= 1 && key <= 10) {
 209   4                                      while (key != 15) {
 210   5                                              if (key >= 1 && key <= 10) guess_cnt = key;
 211   5                                              else if (key == 12) switch_show();
 212   5                                              TempData[5] = dofly_DuanMa[guess_cnt];
 213   5                                              key = KeyPro();
 214   5                                              while (key == 0xff) key = wait_input(5);
 215   5                                      }
 216   4                                      TempData[6] = 0x40;
 217   4                                      key = KeyPro();
 218   4                                      while (~(key >= 1 && key <= 6)) {
 219   5                                              key = KeyPro();
 220   5                                              if (key == 12) switch_show();
 221   5                                      }
 222   4                                      while (key != 15) {
 223   5                                              if (key >= 1 && key <= 6) guess_num = key;
 224   5                                              else if (key == 12) switch_show();
 225   5                                              TempData[7] = dofly_DuanMa[guess_num];
 226   5                                              key = wait_input(7);
 227   5                                              while (key == 0xff) key = wait_input(7);
 228   5                                      }
 229   4                                      UART_SendStr(strcat(itos(guess_cnt), itos(guess_num)));// 傳送猜測
 230   4                                      state = WAIT;
 231   4                              }
 232   3                              else if (key == 15 && catchable) {// 抓
 233   4                                      UART_SendStr("STOP");
 234   4                                      catchable = 0;
 235   4                                      state = WAIT;
 236   4                              }
 237   3                              else if (key == 12) switch_show();
 238   3                      }
 239   2                      else if (state == PREPARE) {
 240   3                              key = wait_input(7);
C51 COMPILER V7.08   MAIN                                                                  06/03/2024 23:12:14 PAGE 5   

 241   3                              while (key != 15) key = wait_input(7);
 242   3                              UART_SendStr("READY");// 準備完成
 243   3                              state = WAIT;
 244   3                      }
 245   2                      else if (state == END) {
 246   3                              key = wait_input(7);
 247   3                              while (~(key == 15 || key == 14)) key = wait_input(7);
 248   3                              if (key == 14) break;
 249   3                              else {
 250   4                                      clearData();// 清屏
 251   4                                      state = PREPARE;
 252   4                              }
 253   3                      }
 254   2              }
 255   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1142    ----
   CONSTANT SIZE    =     35    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
